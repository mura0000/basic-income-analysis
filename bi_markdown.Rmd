---
title: "BI_Analysis"
author: "Yasuaki Murai"
date: "1/17/2020"
output: 
  html_document:
    keep_md: yes
  md_document:
    variant: markdown_github
---

<style type="text/css">
.main-container {
  max-width: 1800px;
  margin-left: auto;
  margin-right: auto;
}
</style>

```{r set-options, echo=FALSE, cache=FALSE}
options(width =1000)
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Basic Income Analysis
The goal is to extract knowledge on what factors are possibly associated with the opinions on basic income, based on a dataset provided by Dalia Research's poll on basic income in European countries in 2016. Specifically, the aim of this project is to gain knowledge about the follwing topics:
<ol>
  <li>How awareness of BI is associated with socio-economic factors</li>
  <li>How the thoughts on the effects of BI is associated with socio-economic factors</li>
  <li>Whether there is an association between awareness and whether a person would vote for BI</li>
  <li>What makes a respondent be for or be against BI </li>
</ol>

### Import libraries
```{r, message=FALSE, warning=FALSE}
library(tidyverse)
library(MASS)
library(nnet)
library(scales)
library(GGally)
library(VGAM)
```

### Import data
```{r}
df = read.csv("basic_income_dataset_dalia.csv")
```

### Define Functions which are going to be used for data preprocesing and other tasks
```{r}
length_sum = function(lst){
  return(lst %>%
           sapply(function(x) return(length(x))) %>%
           sum())
}

string_to_lst = function(strings){
  lst = strings %>% sapply(function(st){
    return(strsplit(x=as.character(st), split = " | ", fixed=TRUE))
  })
  return(lst)
}

indicator_category = function(strings, category){
  lst = string_to_lst(strings)
  indicator = rep(0, length(lst))
  for(i in 1:length(lst)){
    if(category %in% lst[[i]]) indicator[i]=1 
  }
  return(indicator)
}

unique_strings = function(strings){
  lst = string_to_lst(strings)
  dat_vec = character(length = length_sum(lst))
  ind = 1
  for(i in 1:length(lst)){
    for(j in 1:length(lst[[i]])){
      dat_vec[ind] = lst[[i]][j]
      ind = ind + 1
    }
  }
  return(unique(dat_vec))
}

pie_chart_generator = function(var_name, facet_col="none", title){
  p = ggplot(df, aes_string(x=factor(1), fill=var_name)) +
    geom_bar(width=1, position = "fill") +
    labs(title=title) +
    coord_polar(theta="y") +
  theme(
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    axis.ticks.x = element_blank(),
    axis.ticks.y = element_blank(),
    plot.margin = unit(c(0.1,0.1,0.1,0.1), "mm")
  ) +
    scale_y_continuous(breaks=c(0, 0.25, 0.5, 0.75),
                       labels=percent) 
  if(facet_col %in% colnames(df)){
    if(class(df[,facet_col])=="factor") p = p + facet_grid(reformulate(facet_col, "."))
  }
  return(p)
}

bar_prop_generator = function(fill_var, x_var, title, with_n=TRUE, facet_col="none"){
  p = ggplot(df, aes_string(x=x_var)) + 
      geom_bar(aes_string(fill=fill_var), position="fill") +
      geom_text(aes(label=..count..), stat = "count", position = "fill") +
      labs(title=title, y="prop")
  if(facet_col %in% colnames(df)){
    if(class(df[,facet_col])=="factor") p = p + facet_grid(reformulate(facet_col, "."))
  }
  return(p)
}

reason_plots = function(for_or_against = "for"){
  with_parenthesis = sprintf("_%s", for_or_against) 
  vars = colnames(df)[grep(with_parenthesis, colnames(df), fixed=TRUE)]
  reasons_stat = df[,vars] %>% 
    apply(2,sum) %>%
    data.frame()
  colnames(reasons_stat) = "n"
  reasons_stat$reason = rownames(reasons_stat) %>%
   sapply(function(x) return(sub(with_parenthesis, "", x, fixed=TRUE)))
  rownames(reasons_stat) = 1:nrow(reasons_stat)
  num_none_of_the_above = reasons_stat$n[reasons_stat$reason=="None_of_the_above"]
  num_not_none_of_the_above = nrow(df) - num_none_of_the_above
  whether_there_are_reasons = 
    data.frame(response=c("yes", "no"),
              n = c(num_not_none_of_the_above, num_none_of_the_above))
  reasons_stat$prop = reasons_stat$n / num_not_none_of_the_above
  reasons_stat = reasons_stat[,c("reason", "n", "prop")]
  
  plot1 = whether_there_are_reasons %>%
    ggplot(aes(x=response, y=n)) +
    geom_bar(stat="identity") +
    labs(title=sprintf("Number of respondents who did/ did not gave at least one reason for being %s BI", for_or_against))
  
  plot2 = reasons_stat %>%
    ggplot(aes(x=reorder(reason, prop), y=prop)) +
    geom_bar(stat="identity") +
    labs(x="reason", title=sprintf("Reasons for being %s BI", for_or_against)) +
    coord_flip()
  
  return(list(plot1, plot2))
}
```

### Take a quick look at the data
#### Dimension of dataset
```{r}
dim(df)
```

#### Names of Columns
```{r}
colnames(df)
```

Since columns related to opinions each have a long name, they can be shortened.
```{r}
c_name_responses = c("awareness", "vote", "effect", "arguments_for",
           "arguments_against")
colnames(df)[9:13] = c_name_responses
colnames(df)
```

#### Take a look at the data
```{r}
for(i in 1:ncol(df)){
  cat("\n----", colnames(df)[i], "---- \n")
  for(j in 1:5){
     cat("   ", as.character(df[j, i]), "\n")
  }
}
```

It seems values of response-related variables can be fixed so that the values are not too long and reflect, for arguments_for and argements_against columns, 
the fact that those are based on multiple choices of opinions.

### Preprecessing
#### Check for missingness
```{r}
df %>%
  apply(2, function(x) sum(is.na(x)))
```

Only education level has missing values. For now, let the missing values for this variable be treated as "unknown".

```{r}
df$dem_education_level = as.character(df$dem_education_level)
df$dem_education_level[is.na(df$dem_education_level)] = "unknown"
df$dem_education_level = factor(df$dem_education_level,
                                   levels=c("unknown", "no", "low", "medium", "high"))
```


#### awareness
Based on the unique values in the awareness column, shown below, values can be renamed so they are not too long and have no spaces.
```{r}
unique(df$awareness)
df$awareness = df$awareness %>%
  sapply(function(x){
    if(x == "I understand it fully"){return("fully_understand")}
    else if(x == "I know something about it"){return("know_something_about_it")}
    else if(x=="I have heard just a little about it"){return("heard_a_little")}
    else{return("never_heard")}
  }) %>%
  factor(levels=c("never_heard", "heard_a_little" , "know_something_about_it", "fully_understand" ), ordered=TRUE)
```

#### Vote
```{r}
###vote###
unique(df$vote)
df$vote = df$vote %>%
sapply(function(x){
  if(x == "I would vote for it"){return("yes")}
  else if(x == "I would probably vote for it"){return("prob_yes")}
  else if(x=="I would probably vote against it"){return("prob_no")}
  else if(x=="I would vote against it"){return("no")}
  else{return("no_vote")}
}) %>%
  factor(levels=c("no_vote", "no", "prob_no", "prob_yes", "yes"))
```

#### effect
For this variable, the letters "‰Û_ " are included in some of the observations, which are not neccesary and can be removed.
```{r}
unique(df$effect)
df$effect = df$effect %>% sapply(function(x){
  x = as.character(x)
  sub("‰Û_ ", "", x, fixed=TRUE)
}) %>%
  factor()
```

#### arguments_for and arguments_against
For arguments_for and arguments_against, since the values are based on a multiple choice with each of the chosen options separated by the character "|", columns for each option can be created so that for each of the respondents, a cell in a column corresponding to one of the choice options takes 1 if that option is checked and 0 otherwise.
```{r}
###arguments_for###
arguments_for_unique = df$arguments_for %>% 
  unique_strings()
for(i in 1:length(arguments_for_unique)){
  df[gsub(" ", "_", paste(arguments_for_unique[i], "for"))] = df$arguments_for %>% 
     indicator_category(category = paste(arguments_for_unique[i]))
}
colnames(df)[grep("_for", colnames(df))] = 
  gsub("[,-]", "", colnames(df)[grep("_for", colnames(df))])

###arguments_against###
arguments_against_unique = df$arguments_against %>% 
  unique_strings()
for(i in 1:length(arguments_against_unique)){
  df[gsub(" ", "_", paste(arguments_against_unique[i], "against"))] = df$arguments_against %>% 
    indicator_category(category = paste(arguments_against_unique[i]))
}
colnames(df)[grep("_against", colnames(df))] = 
  gsub("[,-]", "", colnames(df)[grep("_against", colnames(df))])
```

Now, the columns arguments_for and arguments_against can be deleted
```{r}
df = df[setdiff(colnames(df), c("arguments_for", "arguments_against"))]
```

### Fix factor orderings
For factor variables with more than 2 levels, levels can be possibly reordered.

#### Create country column
Regarding the country, since there is only a variable for country code, creating a culumn for the country name based on the code could help in making visualization clear in meaning.
```{r}
df$country_code %>% unique()
map_code_name = list(
  AT = "Austria", BE = "Belgium", BG = "Bulgaria",
  CY = "Cyprus", CZ = "Czechia", DE = "Germany",
  DK = "Denamrk", EE = "Estonia", ES = "Spain",
  FI = "Finland", FR = "France", GB = "Britain",
  GR = "Greece", HR = "Croatia", HU = "Hungary",
  IE = "Ireland", IT = "Italy", LT = "Lithuania",
  LU = "Luxembourg", LV = "Latvia", MT = "Malta",
  NL = "Netherlands", PL = "Poland", PT = "Portugal",
  RO = "Romania", SE = "Sweden", SI = "Slovenia",
  SK = "Slovenia"
)
df$country = sapply(df$country_code, function(x)
  return(map_code_name[[as.character(x)]])) %>% 
  as.factor()
```

In addition to this, countries can be divided based on region.
```{r}
map_code_region = list(
  AT = "Central", BE = "Western", BG = "Southeastern",
  CY = "Southeastern", CZ = "Central", DE = "Central",
  DK = "Nordic", EE = "Eastern", ES = "Southern",
  FI = "Nordic", FR = "Western", GB = "Western",
  GR = "Southeastern", HR = "Southeastern", HU = "Central",
  IE = "Western", IT = "Southern", LT = "Eastern",
  LU = "Western", LV = "Eastern", MT = "Southern",
  NL = "Western", PL = "Central", PT = "Southern",
  RO = "Southeastern", SE = "Nordic", SI = "Southeastern",
  SK = "Southeastern"
)
df$region = sapply(df$country_code, function(x)
  return(map_code_region[[as.character(x)]])) %>% 
  as.factor()
```

Now take a look at the first six rows again
```{r}
for(i in 1:ncol(df)){
  cat("----", colnames(df)[i], "---- \n  ")
  for(j in 1:5){
     cat(as.character(df[j, i]), ",")
  }
  cat(as.character(df[6, i]), "\n\n")
}
```
Now, the dataset is in a more analyzable form.

## EDA

### Respondents' countries
```{r}
df %>% 
  group_by(by=country) %>%
  summarise(n=n()) %>% 
  ggplot(aes(x=reorder(by, n), y=n)) +
  geom_bar(stat="identity") +
  xlab("Country") +
  coord_flip() 
```



### education levels
```{r}
df %>% 
  group_by(by=dem_education_level) %>%
  summarise(n=n()) %>% 
  ggplot(aes(x=by, y=n)) +
  geom_bar(stat="identity") +
  xlab("Education Level") 
```

### education levels and full time job for each gender
```{r}
bar_prop_generator("dem_full_time_job", "gender", "dem_full_time_job", with_n=TRUE, facet_col="none")
```


### Awareness
```{r}
df %>% 
  group_by(by=awareness) %>%
  summarise(n=n()) %>% 
  ggplot(aes(x=by, y=n)) +
  geom_bar(stat="identity") +
  xlab("Awareness") 
```

Based on the fact that the majority of the survey respondents fall in either the category "fully_understand"or "know_something_about_it", it seems that, despite the possibility that the awareness is highly dependent on other variables, including social status and political and ecnonomic attributes of a region, BI is overall a well-known idea at least to some extent.

### Vote
```{r}
df %>% 
  group_by(by=vote) %>%
  summarise(n=n()) %>% 
  ggplot(aes(x=by, y=n)) +
  geom_bar(stat="identity") +
  xlab("vote") 
```

It can be seen that a majority of respondents of the survey at least probably would vote for BI. Again, this could be dependent on the social status of a respondent, political or economic attributes of the region they reside in, etc.

### Reasons for for
```{r}
for_plots = reason_plots()
for_plots[[1]]
for_plots[[2]]
```

From the above plots, a number of people seem to think BI reduces financial anxiety.

### Reasons for against
```{r, fig.width=10}
against_plots = reason_plots("against")
against_plots[[1]]
against_plots[[2]]
```

From the above plots, it can be seen that for vast majority of people, there is at least one reason for being against BI in the answer choices.

### Effect
```{r}
df %>%
  group_by(by=effect) %>%
  summarise(n=n()) %>%
  ggplot(aes(x=reorder(by, n), y=n)) +
  geom_bar(stat="identity") +
  labs(title="Opinions on effects",
       x="choice") +
  coord_flip() 
```

It seems that many of the respondents think BI would not lead to job loss, and few people think BI would make them stop working.

## Answering quastions
### 1. How social status is related to whether a person knows about BI
Whether a respondent knows about BI corresponds to the variable awareness. The variable awareness can be considered an ordinal variable with the levels, "never_heard", "heard_a_little", "know_something_about_it", and "fully_understand".
Firstly, let's explore this topic using graphs.

### Graphical Analysis
#### Vs regrion
```{r}
bar_prop_generator("awareness", "region", "awareness vs region")
```

There seem to be some disparities in the level of awareness among different European regions. Specifically, it appears people in Eastern, Southeastern, and Southern regions tend to be more knowledgeable in BI than those in other regions.

##### Plot awareness vs eduction level
```{r}
bar_prop_generator("awareness", "dem_education_level", "awareness vs education level")
```

Despite slight differences, people who have a higher education level on average seem to be more knowledgeable in BI. Let's further partition by whether the resident is from a rural or urban area.

```{r, fig.width=10}
bar_prop_generator("awareness", "dem_education_level", "awareness vs education level by rural", 
                   facet_col = "rural")
```

It seems the trend seems overall not that different, and that whether a person lives in a rural area does not confound the relationship between the education level and the level of awareness. For urban resiednts, however, a respondent from an urban area with "no" education level are more likely to not have heard about BI than a same type of respondent from a rural area. 

##### plot vs age group
```{r}
bar_prop_generator("awareness", "age_group", "awareness vs age group")
```

Slightly, people belonging to older age groups seem to tend to be more knowledgeable in BI.

#### Modelling
Since the level of awareness can be considered an ordered categorical variable, a cumulative logit model can be suitable. The coefficients of the model can be too complex to interpret. One of the possible ways to mitigate this possible problem is to have a proportional odds assumption, in which the coefficients for each of the different response levels only differ by the intercept term. A model with this assumption and without it can be compared based on a certain metric. Since the models are nested, Likelihood ratio test can be used for comparing the models.

##### Multinomial logit model
```{r}
reg_formula_generator = function(output, predictors){
  
  formula_right = paste(predictors, collapse=" + ")
  formula = paste(output, formula_right, sep = " ~ ")
  
  return(as.formula(formula))
}

explanatory_vars = c("age_group", "region", "gender", "rural", 
                     "dem_education_level", "dem_full_time_job", "dem_has_children")
output_var = "awareness"

##Fit models##
#prop odds
mod_po = vglm(reg_formula_generator(output_var, explanatory_vars),
     data=df, family=cumulative(parallel = TRUE))

#non-prop-odds
mod_npo = vglm(reg_formula_generator(output_var, explanatory_vars),
     data=df, family=cumulative())

#Select model
df_diff = 28929 - 28899
lr = deviance(mod_po) - deviance(mod_npo)
p_val_lrt = pchisq(lr, df_diff, lower = F)
if(p_val_lrt < 0.00001){
  cat("P-value of LRT: < 0.00001")
}else{
  cat(sprintf("P-value of LRT: %f", pchisq(ll, df_diff, lower = F)))
}
```

The output of the above code states that the fit significantly improves by having different slope coefficients for each of the response levels. 

The below code's output shows the summary of the non-proportional odds cumulative logit model.
```{r}
summary(mod_npo)
```

Above summary output shows the coefficients in the model corresponding to each response level.

Let's visualize the fitted logit formula for each level.
```{r}
ls = levels(df$awareness)[1:3]
mod_formulas = character(3)

#Matrix for predicted coefs
mod_coefs = coef(mod_npo)
coefs_mat = matrix(0, nrow=3, ncol=16)
for(i in 1:3){
  for(j in 1:16){
    coefs_mat[i, j] = mod_coefs[(i+(j-1)*3)]
  }
}

#Coef names
mod_coef_names = names(coef(mod_npo))[3*1:16]
for(j in 1:length(mod_coef_names)){
  mod_coef_names[j] = substr(mod_coef_names[j], start=1, stop=nchar(mod_coef_names[j])-2)
}

#Create cumulative logit prediction formula for each of the levels.
for(i in 1:3){mod_formulas[i] = sprintf("logit(y<=%s)", ls[i])}
for(i in 1:3){
  mod_formulas[i] = paste(mod_formulas[i], 
                          sprintf("%.5f*(%s)", coefs_mat[i, 1], mod_coef_names[1]), sep=" = ")
for(j in 2:16){
    add_st = sprintf("%.5f*(%s)", coefs_mat[i, j], mod_coef_names[j])
    mod_formulas[i] = paste(mod_formulas[i], add_st, sep = " + \n")
  }
}

for(i in 1:3){
  cat(mod_formulas[i])
  cat("\n\n\n")
}
```

Here, the lower a cofficient, the lower the logit for the corresponding level. In other words, for a certain level and for a certain explanatory variable, if a person belongs to a category of that explanatory variable with a lower coefficient corresponding to the response level, given the other explanatory variables are fixed, the predicted probability that the level of awareness is equal to or lower than the considered level becomes lower (i.e. the predicted probability that the level of awareness is higher than the considered level becomes higher).

For example, considering the coefficients related the variable dem_education_level at the level know_something_about_it, the education level of "high" has the lowest corresponding coef value. Therefore, given the values of the other variables fixed, a person with a "high" education level has a lower probability of having the awareness level of know_something_about_it or lower. This in turn means a higher predicted probability of having the highest awareness level, "fully_understand".

Looking at the scales of the coefficents at each level of awareness, overall, education level and region tend to have high contributions to the predictions than other variables. 

This result does not guarantee the causal relationship as there is a possibility of the existence of omitted variable bias. However, based on the above result, a hypothesis can be made that the level of awareness might be related to the level of education and the region. 

As a possible way to further explore the factors possibly influencing the level of awareness, rather than using region as an explanatory variable, country specific values of socio-economic attributes, such as GDP and unemployment rate, can be taken as alternative explanatory variables. In this way, not only in what regions people tend to have a higher level of awareness, but also what country, or region-specific factors are related to the people's level of awareness can be possibly seen.

Using the above formulas, given the value of each of the attributes, the predicted probability of each level can be derived. As an example, let's see how the level of education affects the predicted probabilities. In order to make comparisons based on the educational level, values of the other variables must be fixed. In this example, the other variables are fixed at default values of the pred_mod dunction (please see the function definition).

```{r}
pred_mod = function(age_group="14_25", region="Central", gender="female", 
                    rural="rural", edu_level="unknown", 
                    full_time_job="no", has_children="no"){
  ###age_group, region, gender, rural, dem_education_level, dem_full_time_job, dem_has_children
  
  #####Create vector X#####
  X = rep(0, 16)
  
  #Intercept
  X[1] = 1
  
  #Age group
  if(age_group=="26_39"){X[2] = 1}
  else if(age_group=="40_65"){X[3] = 1}
  
  #region
  if(region=="Eastern"){X[4]=1}
  else if(region=="Nordic"){X[5]=1}
  else if(region=="Southeastern"){X[6]=1}
  else if(region=="Southern"){X[7]=1}
  else if(region=="Western"){X[8]=1}
  
  #gender
  if(gender=="male"){X[9]=1}
  
  #rural
  if(rural=="urban"){X[10]=1}
  
  #edu level
  if(edu_level=="no"){X[11]=1}
  else if(edu_level=="low"){X[12]=1}
  else if(edu_level=="medium"){X[13]=1}
  else if(edu_level=="high"){X[14]=1}
  
  #fulltime job
  if(full_time_job=="yes"){X[15]=1}
  
  #children
  if(has_children=="yes"){X[16]=1}
  
  #Get predict values
  logit_val = numeric(3)
  probs = numeric(3)
  for(i in 1:3){
    logit_val[i] = sum(X * coefs_mat[i,])
    probs[i] = 1/(1 + exp(-logit_val[i]))
  }
  return(list(logits=logit_val, probs=probs))
}

edu_levels = c("unknown", "no", "low", "medium", "high")
for(lvl in edu_levels){
  prob_pred = pred_mod(edu_level=lvl)
  
  p_never = prob_pred$probs[1]
  p_little = prob_pred$probs[2] - prob_pred$probs[1]
  p_something =  prob_pred$probs[3] - prob_pred$probs[2]
  p_fully = 1 - prob_pred$probs[3]
  
  cat(sprintf("--------Probs for dem_education_level=%s--------\n", lvl))
  cat(sprintf("Prob of never_heard: %.5f \n", p_never))
  cat(sprintf("Prob of heard a little: %.5f \n", p_little))
  cat(sprintf("Prob of know something: %.5f \n", p_something))
  cat(sprintf("Prob of fully_understand: %.5f \n\n", p_fully))
}
```

It can be seen that the predicted probabilities of having a higher level of awareness (fully_understand, or know_something) are in general higher for a person having a high education level.

Despite the fact that causal relationship cannot be guaranteed, another way to possibly infer this is to fit a Random Forest classifier and see the importance measure of each explanatory variable considered, based on the mean decrease in Gini coef. 
```{r}
library(randomForest)
explanatory_vars = c("age_group", "region", "gender", "rural", 
                     "dem_education_level", "dem_full_time_job", "dem_has_children")
rf = randomForest::randomForest(x=df[explanatory_vars], y=df$awareness, ntree=5000)
rf$importance
```

Based on the importance measures above, education level and region might be related to the level of awareness more than other variables in the dataset, which agrees with the results of fitting the cumulative logit model. 


### 2. How notion on the effects of BI is associated with social status
#### Graphical Analysis
##### Plot 
```{r}
bar_prop_generator("effect", "age_group", "effect vs age group", facet_col="gender")
```

There are apparent differences in the proportion of the people who think BI would not affect their work choices. Specifically, for both male and female, the proportion of the people who think BI would not affect their work choices is higher for older age groups.

```{r}
bar_prop_generator("effect", "dem_education_level", "effect vs education level")
```

It can be seen that people with a higher education level tend to think that BI would not affect their work choices.

##### Modelling
Since there are many choices for the effects, a multinomial logit model would be too complex to interpret. 

```{r}
explanatory_vars = c("age_group", "region", "gender", "rural", 
                     "dem_education_level", "dem_full_time_job", "dem_has_children")
library(randomForest())
rf_effect = randomForest(x= df[explanatory_vars], y=df$effect, ntree = 1000)
rf_effect$importance
```

Based on the importance measure, education level and region seem to be more relevant than other variables.

### 3. Whether there is an association between awareness and whether a person would vote for BI
#### graphical Analysis
```{r}
bar_prop_generator("vote", "awareness", "vote vs awareness")
```

The above plot shows that the more knowledge one has about BI, the more likely he would vote for BI. It can be inferred from the above plot that the vote and awareness are not independent or homogeneous, let's do Chi square test for independence

#### Chi-square test
```{r}
chisq.test(x=df$vote, y=df$awareness)
```

#### Correspondence analysis
```{r}
library(FactoMineR)
library(factoextra)
table_awareness_vote = table(df$awareness, df$vote)
CA(table_awareness_vote)
```


### 4. What are the possible reasons for a respondent to not vote for BI
```{r}
for_reasons = colnames(df)[grep("_for", colnames(df))]
against_reasons = colnames(df)[grep("_against", colnames(df))]
```

#### Graphical analysis
##### 
```{r}
df %>% 
  group_by(by=vote) %>%
  summarise(n=n()) %>% 
  ggplot(aes(x=by, y=n)) +
  geom_bar(stat="identity") +
  xlab("vote") 
```

The above plot is also shown in the EDA section.

#####  visualize the reasons of for
```{r}
for_plots = reason_plots()
for_plots[[1]]
for_plots[[2]]
```

The above plots are displayed also in the EDA section.

##### visualize reasons of against
```{r}
against_plots = reason_plots("against")
against_plots[[1]]
against_plots[[2]]
```

The above plots are displayed also in the EDA section.

```{r}
table_prop_plot = function(tdf){
  title = gsub("-", " ", colnames(tdf)[1])
  return(tdf %>%
    ggplot(aes_string(x=colnames(tdf)[1], 
                      y=colnames(tdf)[3],
                      fill=colnames(tdf)[2])) +
      geom_bar(stat="identity", position="fill") +
      labs(title=title) +
      theme(axis.title.x = element_blank())
    
    ) 
}



for(i in 1:length(for_reasons)){
  tdf = data.frame(table(df[,c(for_reasons[i], "vote")]))
  print(table_prop_plot(tdf))
}

for(i in 1:length(against_reasons)){
  tdf = data.frame(table(df[,c(against_reasons[i], "vote")]))
  print(table_prop_plot(tdf))
}
```


The columns for the reasons for being for/against the BI along with the variable vote.
In order to simplify analysis, the levels for vote can be collapsed into three levels, "Yes", which includes the levels "yes" and "prob_yes" in the original formulation, "No", which includes "no" and "prob_no", and "NO_VOTE", which includes "no_vote.

A multinomial logit model will be fit with the reference category "NO". 

Collapsing the categories can lead to some loss of information. However, in the multinomial logit model described above, factors which possibly have a relationship with whether one votes for BI or not can be seen by referring to the coefficients related to the category "YES".

There can be loss of information by doing the above thing. However, by fi

In addition, in order to take account of the possibility of the existence confounding variables, variables related to socio-economic factors, which are used in modelling awareness, are also going to be in the model.

```{r}
collpase_vote = function(vote){
  process_func = function(x){
   if(x %in% c("yes", "prob_yes")){
      return("YES")
    }else if(x %in% c("no", "prob_no")){
      return("NO")
    }else{
     return("NO_VOTE")
    } 
  }
  
  ret_vec = character(length(vote))
  for(i in 1:length(vote)){
    ret_vec[i] = process_func(vote[i])
  }

  return(factor(ret_vec, levels=c("NO", "YES", "NO_VOTE")))
}

df = df %>%
  mutate(
    vote_collapsed = collpase_vote(vote)
  )

mod_VOTE = multinom(reg_formula_generator("vote_collapsed", 
                                     c(explanatory_vars, for_reasons, against_reasons)),
               data = df)
```

```{r}
summary(mod_VOTE)
```

```{r}
coef_names = names(data.frame(coef(mod_VOTE))[1,])
yes_coefs = numeric(length(coef_names))

for(i in 1:length(yes_coefs)){
  yes_coefs[i] = data.frame(coef(mod_VOTE))[1,i]
}

for(i in 1:length(yes_coefs)){
  cat(sprintf("%s: %.5f \n", coef_names[i], yes_coefs[i]))
}
```