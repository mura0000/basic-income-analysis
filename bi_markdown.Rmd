---
title: "BI_Analysis"
author: "Yasuaki Murai"
date: "1/17/2020"
output: 
  md_document:
    variant: markdown_github
---

<style type="text/css">
.main-container {
  max-width: 1800px;
  margin-left: auto;
  margin-right: auto;
}
</style>

```{r set-options, echo=FALSE, cache=FALSE}
options(width =1000)
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Basic Income Analysis
The goal is to extract knowledge on what factors are possibly associated with the opinions on basic income, based on a dataset provided by Dalia Research's poll on basic income in European countries in 2016. Specifically, the aim of this project is to gain knowledge about the follwing topics:
<ol>
  <li>How awareness of BI is associated with socio-economic factors</li>
  <li>How the thoughts on the effects of BI is associated with socio-economic factors</li>
  <li>Whether there is an association between awareness and whether a person would vote for BI</li>
  <li>How awareness is related to thoughts on the effects </li>
  <li>What makes a respondent be for or be against BI </li>
</ol>

### Import libraries
```{r, message=FALSE, warning=FALSE}
library(tidyverse)
library(MASS)
library(nnet)
library(scales)
library(GGally)
```

### Import data
```{r}
df = read.csv("basic_income_dataset_dalia.csv")
```

### Define Functions which are going to be used for data preprocesing and other tasks
```{r}
length_sum = function(lst){
  return(lst %>%
           sapply(function(x) return(length(x))) %>%
           sum())
}

string_to_lst = function(strings){
  lst = strings %>% sapply(function(st){
    return(strsplit(x=as.character(st), split = " | ", fixed=TRUE))
  })
  return(lst)
}

indicator_category = function(strings, category){
  lst = string_to_lst(strings)
  indicator = rep(0, length(lst))
  for(i in 1:length(lst)){
    if(category %in% lst[[i]]) indicator[i]=1 
  }
  return(indicator)
}

unique_strings = function(strings){
  lst = string_to_lst(strings)
  dat_vec = character(length = length_sum(lst))
  ind = 1
  for(i in 1:length(lst)){
    for(j in 1:length(lst[[i]])){
      dat_vec[ind] = lst[[i]][j]
      ind = ind + 1
    }
  }
  return(unique(dat_vec))
}

pie_chart_generator = function(var_name, facet_col="none", title){
  p = ggplot(df, aes_string(x=factor(1), fill=var_name)) +
    geom_bar(width=1, position = "fill") +
    labs(title=title) +
    coord_polar(theta="y") +
  theme(
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    axis.ticks.x = element_blank(),
    axis.ticks.y = element_blank(),
    plot.margin = unit(c(0.1,0.1,0.1,0.1), "mm")
  ) +
    scale_y_continuous(breaks=c(0, 0.25, 0.5, 0.75),
                       labels=percent) 
  if(facet_col %in% colnames(df)){
    if(class(df[,facet_col])=="factor") p = p + facet_grid(reformulate(facet_col, "."))
  }
  return(p)
}

bar_prop_generator = function(fill_var, x_var, title, with_n=TRUE, facet_col="none"){
  p = ggplot(df, aes_string(x=x_var)) + 
      geom_bar(aes_string(fill=fill_var), position="fill") +
      geom_text(aes(label=..count..), stat = "count", position = "fill") +
      labs(title=title, y="prop")
  if(facet_col %in% colnames(df)){
    if(class(df[,facet_col])=="factor") p = p + facet_grid(reformulate(facet_col, "."))
  }
  return(p)
}

reason_plots = function(for_or_against = "for"){
  with_parenthesis = sprintf(" (%s)", for_or_against) 
  vars = colnames(df)[grep(with_parenthesis, colnames(df), fixed=TRUE)]
  reasons_stat = df[,vars] %>% 
    apply(2,sum) %>%
    data.frame()
  colnames(reasons_stat) = "n"
  reasons_stat$reason = rownames(reasons_stat) %>%
   sapply(function(x) return(sub(with_parenthesis, "", x, fixed=TRUE)))
  rownames(reasons_stat) = 1:nrow(reasons_stat)
  num_none_of_the_above = reasons_stat$n[reasons_stat$reason=="None of the above"]
  num_not_none_of_the_above = nrow(df) - num_none_of_the_above
  whether_there_are_reasons = 
    data.frame(response=c("yes", "no"),
              n = c(num_not_none_of_the_above, num_none_of_the_above))
  reasons_stat$prop = reasons_stat$n / num_not_none_of_the_above
  reasons_stat = reasons_stat[,c("reason", "n", "prop")]
  
  plot1 = whether_there_are_reasons %>%
    ggplot(aes(x=response, y=n)) +
    geom_bar(stat="identity") +
    labs(title=sprintf("Number of respondents who did/ did not gave at least one reason for being %s BI", for_or_against))
  
  plot2 = reasons_stat %>%
    ggplot(aes(x=reorder(reason, prop), y=prop)) +
    geom_bar(stat="identity") +
    labs(x="reason", title=sprintf("Reasons for being %s BI", for_or_against)) +
    coord_flip()
  
  return(list(plot1, plot2))
}
```

### Take a quick look at the data
#### Dimension of dataset
```{r}
dim(df)
```

#### Names of Columns
```{r}
colnames(df)
```

Since columns related to opinions each have a long name, they can be shortened.
```{r}
c_name_responses = c("awareness", "vote", "effect", "arguments_for",
           "arguments_against")
colnames(df)[9:13] = c_name_responses
colnames(df)
```

#### Take a look at the data
```{r}
for(i in 1:ncol(df)){
  cat("\n----", colnames(df)[i], "---- \n")
  for(j in 1:5){
     cat("   ", as.character(df[j, i]), "\n")
  }
}
```

It seems values for response-related variables can be fixed so that the values are not too long and reflect, for arguments_for and argements_against columns, 
the fact that those are based on multiple choices of opinions.

### Preprecessing
#### Check for missingness
```{r}
df %>%
  apply(2, function(x) sum(is.na(x)))
```

Only education level has missing values. For now, let the missing values for this variable be treated as "unknown".

```{r}
df$dem_education_level = as.character(df$dem_education_level)
df$dem_education_level[is.na(df$dem_education_level)] = "unknown"
df$dem_education_level = factor(df$dem_education_level,
                                   levels=c("unknown", "no", "low", "medium", "high"))
```


#### awareness
Based on the unique values in the awareness column, shown below, values can be renamed so they are not too long and have no spaces.
```{r}
unique(df$awareness)
df$awareness = df$awareness %>%
  sapply(function(x){
    if(x == "I understand it fully"){return("fully_understand")}
    else if(x == "I know something about it"){return("know_something_about_it")}
    else if(x=="I have heard just a little about it"){return("heard_a_little")}
    else{return("never_heard")}
  }) %>%
  factor(levels=c("never_heard", "heard_a_little" , "know_something_about_it", "fully_understand" ))
```

#### Vote
```{r}
###vote###
unique(df$vote)
df$vote = df$vote %>%
sapply(function(x){
  if(x == "I would vote for it"){return("yes")}
  else if(x == "I would probably vote for it"){return("prob_yes")}
  else if(x=="I would probably vote against it"){return("prob_no")}
  else if(x=="I would vote against it"){return("no")}
  else{return("no_vote")}
}) %>%
  factor(levels=c("no_vote", "no", "prob_no", "prob_yes", "yes"))
```

#### effect
For this variable, the letters "‰Û_ " are included for some of the observations, which are not neccesary and can be removed.
```{r}
unique(df$effect)
df$effect = df$effect %>% sapply(function(x){
  x = as.character(x)
  sub("‰Û_ ", "", x, fixed=TRUE)
}) %>%
  factor()
```

#### arguments_for and arguments_against
For arguments_for and arguments_against, since the values are based on a multiple choice with each of the chosen options separated by the character | for each respondent, columns for each option can be created so that for a respondent, a cell in a column corresponding to one of the choice options takes 1 if that option is checked and 0 otherwise.
```{r}
###arguments_for###
arguments_for_unique = df$arguments_for %>% 
  unique_strings()
for(i in 1:length(arguments_for_unique)){
  df[paste(arguments_for_unique[i], "(for)")] = df$arguments_for %>% 
     indicator_category(category = paste(arguments_for_unique[i]))
}

###arguments_against###
arguments_against_unique = df$arguments_against %>% 
  unique_strings()
for(i in 1:length(arguments_against_unique)){
  df[paste(arguments_against_unique[i], "(against)")] = df$arguments_against %>% 
    indicator_category(category = paste(arguments_against_unique[i]))
}
```

Now, the columns arguments_for and arguments_against can be deleted
```{r}
df = df[setdiff(colnames(df), c("arguments_for", "arguments_against"))]
```

### Fix factor orderings
For factor variables with more than 2 levels, levels can be possibly reordered.

#### Create country column
Since there is only variable for country code, creating a culumn for the country name based on the code could help in making visualization clear in meaning.
```{r}
df$country_code %>% unique()
map_code_name = list(
  AT = "Austria", BE = "Belgium", BG = "Bulgaria",
  CY = "Cyprus", CZ = "Czechia", DE = "Germany",
  DK = "Denamrk", EE = "Estonia", ES = "Spain",
  FI = "Finland", FR = "France", GB = "Britain",
  GR = "Greece", HR = "Croatia", HU = "Hungary",
  IE = "Ireland", IT = "Italy", LT = "Lithuania",
  LU = "Luxembourg", LV = "Latvia", MT = "Malta",
  NL = "Netherlands", PL = "Poland", PT = "Portugal",
  RO = "Romania", SE = "Sweden", SI = "Slovenia",
  SK = "Slovenia"
)
df$country = sapply(df$country_code, function(x)
  return(map_code_name[[as.character(x)]])) %>% 
  as.factor()
```

In addition to this, countries can be divided based region,
```{r}
map_code_region = list(
  AT = "Central", BE = "Western", BG = "Southeastern",
  CY = "Southeastern", CZ = "Central", DE = "Central",
  DK = "Nordic", EE = "Eastern", ES = "Southern",
  FI = "Nordic", FR = "Western", GB = "Western",
  GR = "Southeastern", HR = "Southeastern", HU = "Central",
  IE = "Western", IT = "Southern", LT = "Eastern",
  LU = "Western", LV = "Eastern", MT = "Southern",
  NL = "Western", PL = "Central", PT = "Southern",
  RO = "Southeastern", SE = "Nordic", SI = "Southeastern",
  SK = "Southeastern"
)
df$region = sapply(df$country_code, function(x)
  return(map_code_region[[as.character(x)]])) %>% 
  as.factor()
```

Now take a look at the first six rows again
```{r}
for(i in 1:ncol(df)){
  cat("----", colnames(df)[i], "---- \n  ")
  for(j in 1:5){
     cat(as.character(df[j, i]), ",")
  }
  cat(as.character(df[6, i]), "\n\n")
}
```
Now, the dataset is in a more analyzable form.

## EDA

### Respondents' countries
```{r}
df %>% 
  group_by(by=country) %>%
  summarise(n=n()) %>% 
  ggplot(aes(x=reorder(by, n), y=n)) +
  geom_bar(stat="identity") +
  xlab("Country") +
  coord_flip() 
```



### education levels
```{r}
df %>% 
  group_by(by=dem_education_level) %>%
  summarise(n=n()) %>% 
  ggplot(aes(x=by, y=n)) +
  geom_bar(stat="identity") +
  xlab("Education Level") 
```

### education levels and full time job for each gender
```{r}
bar_prop_generator("dem_full_time_job", "gender", "dem_full_time_job", with_n=TRUE, facet_col="none")
```


### Awareness
```{r}
df %>% 
  group_by(by=awareness) %>%
  summarise(n=n()) %>% 
  ggplot(aes(x=by, y=n)) +
  geom_bar(stat="identity") +
  xlab("Awareness") 
```

Based on the fact that the majority of the survey respondents fall in either the category "fully_understand"or "know_something_about_it", it seems that, despite the possibility that the awareness is highly dependent on other variables, including social status and political and ecnonomic attributes of a region, BI is overall a well-known idea at least to some extent.

### Vote
```{r}
df %>% 
  group_by(by=vote) %>%
  summarise(n=n()) %>% 
  ggplot(aes(x=by, y=n)) +
  geom_bar(stat="identity") +
  xlab("vote") 
```

It can be seen that a majority of respondents of the survey at least probably would vote for BI. Again, this could be dependent on the social status of a respondent, political or economic attributes of the region they reside in, etc.

### Reasons for for
```{r}
for_plots = reason_plots()
for_plots[[1]]
for_plots[[2]]
```

From the above plots, a number of people seem to think BI reduces financial anxiety.

### Reasons for against
```{r, fig.width=10}
against_plots = reason_plots("against")
against_plots[[1]]
against_plots[[2]]
```

From the above plots, it can be seen that for vast majority of people, there is at least one reason to be against BI in the answer choices.

### Effect
```{r}
df %>%
  group_by(by=effect) %>%
  summarise(n=n()) %>%
  ggplot(aes(x=reorder(by, n), y=n)) +
  geom_bar(stat="identity") +
  labs(title="Opinions on effects",
       x="choice") +
  coord_flip() 
```

It seems that many of the respondents think BI would not lead to job loss, and few people think BI would make them stop working.

## Answering quastions
### 1. How social status is related to whether a person knows about BI
Whether a respondent knows about BI corresponds to the variable awareness. The variable awareness can be considered an ordinal variable with the categories, "never_heard", "heard_a_little", "know_something_about_it", and "fully_understand".
Firstly, let's explore this topic through grapshs.

### Graphical Analysis
#### Vs regrion
```{r}
bar_prop_generator("awareness", "region", "awareness vs education level")
```

##### Plot awareness vs eduction level
```{r}
bar_prop_generator("awareness", "dem_education_level", "awareness vs education level")
```

Despite slight differences, people who have a high education level on average are more knowledgeable in BI. Let's partition by whether the resident is rural or urban.

```{r, fig.width=10}
bar_prop_generator("awareness", "dem_education_level", "awareness vs education level by rural", 
                   facet_col = "rural")
```

It seems the trend is not that different, and so whether a person lives in a rural area does not confound the relationship between the education level and the level of awareness.

##### plot vs age group
```{r}
bar_prop_generator("awareness", "age_group", "awareness vs age group")
```

Slightly, people belonging to older age groups seem to be more knowledgeable in BI.

#### Modelling
For modelling, I will use Generalized Linear Models. Two ways of treating the variable awareness are considered. First is to treat the variable as an unordered categorical variable. In this case, multinomial logit model can be fit. The second way is to treat the variable as an ordinal variable, with the levels "never_heard", "heard_a_little", "know_something_about_it", and "fully_understand". Cumulative logit model (proportional/non-proportional odds) is considered in this case. Models then can be compared, and inferences can be made based on the best model.

##### Multinomial logit model
Final model is selected based on forward search with the use of likelihood ratio as the criterion. Two-way interactions are alco taken into account.
```{r}

#age_group, region, gender, rural, dem_education_level, dem_full_time_job, dem_has_children
mod_intercept = multinom(awareness ~ 1, data=df, trace=FALSE)



explanatory_vars = c("age_group", "region", "gender", "rural", 
                     "dem_education_level", "dem_full_time_job", "dem_has_children")
deviance_null = mod_intercept$deviance
edf_null = mod_intercept$edf


formula_right = "1 "
for(i in 1:7){
  p_val = numeric(length(explanatory_vars))
  edf = numeric(length(explanatory_vars))
  dev = numeric(length(explanatory_vars))
  
  for(j in 1:length(explanatory_vars)){
    new_formula_right = paste(formula_right, "+ ", explanatory_vars[j], sep="")
    new_formula_string = paste("awareness ~ ", new_formula_right, sep="")
    mod = multinom(as.formula(new_formula_string), data=df, trace=FALSE)
    dev[j] = mod$deviance
    edf[j] = mod$edf
    p_val[j] = 1 - pchisq(deviance_null - dev[j], df=edf[j] - edf_null)
  }
  
  min_pval_j = which(p_val==min(p_val))[1]
  if(p_val[min_pval_j] < 0.05){
    formula_right = paste(formula_right, " + ", explanatory_vars[min_pval_j], sep="")
    explanatory_vars = explanatory_vars[-min_pval_j]
    deviance_null = dev[min_pval_j]
    edf_null = edf[min_pval_j]
  }else{
    break
  }
}

cat("The final main effects model is", formula_right, ".")
```



```{r}
mod_main_effects = 
  multinom(awareness ~ 1  + age_group + region + dem_education_level + gender + dem_full_time_job,
           data=df, trace=FALSE)
deviance_null = mod_main_effects$deviance
edf_null = mod_main_effects$edf


explanatory_vars = c("age_group", "region", "dem_education_level", "gender", "dem_full_time_job")
interaction_formulas = character(10)
k=1
for(i in 1:4){
  for(j in (i+1):5){
    interaction_formulas[k] = paste(explanatory_vars[i], ":", explanatory_vars[j], sep="")
    k = k + 1
  }
}


formula_right = "1  + age_group + region + dem_education_level + gender + dem_full_time_job"
for(i in 1:10){
  p_val = numeric(length(interaction_formulas))
  edf = numeric(length(interaction_formulas))
  dev = numeric(length(interaction_formulas))
  
  for(j in 1:length(interaction_formulas)){
    new_formula_right = paste(formula_right, "+ ", interaction_formulas[j], sep="")
    new_formula_string = paste("awareness ~ ", new_formula_right, sep="")
    mod = multinom(as.formula(new_formula_string), data=df, trace=FALSE)
    dev[j] = mod$deviance
    edf[j] = mod$edf
    p_val[j] = 1 - pchisq(deviance_null - dev[j], df=edf[j] - edf_null)
  }
  
  min_pval_j = which(p_val==min(p_val))[1]
  if(p_val[min_pval_j] < 0.05){
    formula_right = paste(formula_right, " + ", interaction_formulas[min_pval_j], sep="")
    interaction_formulas = interaction_formulas[-min_pval_j]
    deviance_null = dev[min_pval_j]
    edf_null = edf[min_pval_j]
  }else{
    break
  }
}

cat("The final second order model is", formula_right, ".")
```



```{r}
mod_formula = paste("awareness ~ ", formula_right, sep="")
mod_second_order = multinom(as.formula(mod_formula), data=df, trace=FALSE)
anova(mod_main_effects, mod_second_order)
```

Comparing the final main effects model and the second order model, based on the p-value of the likelihood ratio test, the second-order model can be taken as the final model.

```{r}
#mod_second_order_predicors = c("")
cbind(predict(mod_second_order, type = "prob"), as.character(df$awareness))
```


```{r}
library(randomForest)
explanatory_vars = c("age_group", "region", "gender", "rural", 
                     "dem_education_level", "dem_full_time_job", "dem_has_children")
rf = randomForest::randomForest(x=df[explanatory_vars], y=df$awareness, ntree=5000)
rf$importance
predict(rf, type="prob")
table(predict(rf), df$awareness)
```



### 2. How notion on the effects of BI is associated with social status
#### Graphical Analysis
##### Plot 
```{r}
colnames(df)
```

```{r}
bar_prop_generator("effect", "age_group", "effect vs age group", facet_col="gender")
```

```{r}
bar_prop_generator("effect", "dem_education_level", "effect vs age group")
```


##### Modelling
```{r}
mod_effect = multinom(effect ~ age_group + gender + rural + region + dem_education_level + dem_full_time_job +  dem_has_children,
                      data=df, trace=FALSE)
mod_effect
```
```{r}
table(df$effect, predict(mod_effect))
```


```{r}
explanatory_vars = c("age_group", "region", "gender", "rural", 
                     "dem_education_level", "dem_full_time_job", "dem_has_children")
rf_effect = randomForest(x= df[explanatory_vars], y=df$effect, ntree = 1000)
rf_effect$importance
```

### 3. Whether there is an association between awareness and whether a person would vote for BI
```{r}
table_mat = as.matrix(table(df$awareness, df$vote))
nums_vote = apply(table_mat, 1, sum)
mat_nums_awareness = nums_vote %*%  matrix(1, ncol=length(unique(df$vote)), nrow=1)
table_mat/mat_nums_awareness
```

```{r}
head(df)
```

### 4. How awareness is related to thoughts on the effects
```{r}
chisq.test(table(df$effect, df$awareness))
table_mat = as.matrix(table(df$effect, df$awareness))
nums_awareness = apply(table_mat, 2, sum)
mat_nums_awareness = matrix(1, nrow=length(unique(df$effect)), ncol=1) %*% t(nums_awareness)
table_mat/mat_nums_awareness
```

### 5. What are the possible reasons for a respondent to be for or against BI


